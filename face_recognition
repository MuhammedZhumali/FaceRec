#!/usr/bin/env python3
import cv2
import sys
import pickle
import bcrypt
import face_recognition
import numpy as np
import dlib
import RPi.GPIO as GPIO
import time
import tkinter as tk
from tkinter import simpledialog

# === GUI prompt for passport ID ===
def ask_passport():
    root = tk.Tk()
    root.withdraw()
    p = simpledialog.askstring("Passport", "Enter your Passport ID:")
    root.destroy()
    return p

# === CONFIG ===
ENC_PATH      = "encodings.pickle"
THRESHOLD     = 0.4
DETECT_EVERY  = 3
CAM_WIDTH     = 640
CAM_HEIGHT    = 480

SERVO_PIN     = 22
OPEN_DC       = 15   
CLOSED_DC     = 5   
OPEN_DURATION = 5.0   # seconds gate stays open

GPIO.setmode(GPIO.BOARD)
GPIO.setup(SERVO_PIN, GPIO.OUT)
servo = GPIO.PWM(SERVO_PIN, 50)  # 50 Hz
servo.start(CLOSED_DC)
servo_open = False
open_time = 0

# === auto-detect camera ===
def find_camera():
    for i in range(5):
        cap = cv2.VideoCapture(i, cv2.CAP_V4L2)
        if cap.isOpened():
            w = cap.get(cv2.CAP_PROP_FRAME_WIDTH)
            h = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
            print(f"[INFO] Camera index {i} opened at {int(w)}×{int(h)}")
            return cap
        cap.release()
    print("[ERROR] No camera found on indices 0–4")
    sys.exit(1)

# === load face encodings ===
with open(ENC_PATH, "rb") as f:
    db = pickle.load(f)
all_encs, all_hashes, salt = db["encodings"], db["hashed_names"], db["salt"]

# === prompt passport & filter encodings ===
passport = ask_passport()
if not passport:
    print("[ERROR] Passport entry cancelled.")
    sys.exit(1)
pw = passport.strip().encode()
h  = bcrypt.hashpw(pw, salt)
known_encs = [e for e, hh in zip(all_encs, all_hashes) if hh == h]
if not known_encs:
    print(f"[ERROR] No encodings found for {passport}")
    sys.exit(1)
print(f"[INFO] Loaded {len(known_encs)} face encodings for {passport}")

# === initialize face detector ===
cascade = cv2.CascadeClassifier(
    cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
)

# === open camera ===
cap = find_camera()
cap.set(cv2.CAP_PROP_FRAME_WIDTH, CAM_WIDTH)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, CAM_HEIGHT)

print("[INFO] Starting face recognition. Press 'q' to quit.")

trackers    = []  # each: [dlib_tracker, recognized_flag]
frame_count = 0

try:
    while True:
        ret, frame = cap.read()
        if not ret:
            continue

        frame_count += 1
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

        # (re)detect faces every DETECT_EVERY frames or if no trackers
        if frame_count % DETECT_EVERY == 1 or not trackers:
            trackers.clear()
            gray  = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            faces = cascade.detectMultiScale(gray, 1.1, 5, minSize=(60,60))
            for (x, y, w, h) in faces:
                top, right = y, x + w
                bottom, left = y + h, x
                encs = face_recognition.face_encodings(
                    rgb, [(top, right, bottom, left)]
                )
                if not encs:
                    continue
                dist       = np.min(face_recognition.face_distance(known_encs, encs[0]))
                recognized = (dist < THRESHOLD)
                tr = dlib.correlation_tracker()
                tr.start_track(frame, dlib.rectangle(left, top, right, bottom))
                trackers.append([tr, recognized])

        # draw & check for any match
        display     = frame.copy()
        any_matched = False
        for tr, recognized in trackers:
            tr.update(frame)
            pos = tr.get_position()
            l, t = int(pos.left()), int(pos.top())
            r, b = int(pos.right()), int(pos.bottom())

            if recognized:
                label, color = f"MATCH {passport}", (0,255,0)
                any_matched  = True
            else:
                label, color = "Unknown", (0,0,255)

            cv2.rectangle(display, (l, t), (r, b), color, 2)
            cv2.putText(display, label, (l+5, t-5),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 1)

        # SERVO CONTROL
        now = time.time()
        if any_matched and not servo_open:
            servo.ChangeDutyCycle(OPEN_DC)
            servo_open = True
            open_time = now
            print("[INFO] Gate opened")
        elif servo_open and (now - open_time) >= OPEN_DURATION:
            servo.ChangeDutyCycle(CLOSED_DC)
            servo_open = False
            print("[INFO] Gate closed")

        cv2.imshow("Face Recognition", display)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

finally:
    servo.ChangeDutyCycle(CLOSED_DC)
    time.sleep(0.5)
    servo.stop()
    GPIO.cleanup()
    cap.release()
    cv2.destroyAllWindows()